import React, { useEffect, useMemo, useState } from "react";
import {
  Box,
  Drawer,
  Typography,
  Tabs,
  Tab,
  IconButton,
  Divider,
  CircularProgress,
  Chip,
  Tooltip,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
} from "@mui/material";
import CloseIcon from "@mui/icons-material/Close";
import { apiGet, toApiError, type ApiError } from "../api";
import { useConnectionState } from "../connectionState";
import IngressDrawer from "./IngressDrawer";
import PodDrawer from "./PodDrawer";
import { fmtAge, fmtTs, valueOrDash } from "../utils/format";
import Section from "./shared/Section";
import KeyValueTable from "./shared/KeyValueTable";
import AccessDeniedState from "./shared/AccessDeniedState";
import EmptyState from "./shared/EmptyState";
import ErrorState from "./shared/ErrorState";
import MetadataSection from "./shared/MetadataSection";
import EventsList from "./shared/EventsList";
import CodeBlock from "./shared/CodeBlock";

type ServiceDetails = {
  summary: ServiceSummary;
  ports: ServicePort[];
  traffic: ServiceTraffic;
  endpoints: ServiceEndpoints;
  yaml: string;
};

type EventDTO = {
  type: string;
  reason: string;
  message: string;
  count: number;
  firstSeen: number;
  lastSeen: number;
};

type ServiceSummary = {
  name: string;
  namespace: string;
  type: string;
  clusterIPs?: string[];
  externalName?: string;
  selector?: Record<string, string>;
  sessionAffinity?: string;
  ageSec?: number;
  labels?: Record<string, string>;
  annotations?: Record<string, string>;
};

type ServicePort = {
  name?: string;
  port: number;
  targetPort?: string;
  protocol?: string;
  nodePort?: number;
};

type ServiceTraffic = {
  externalTrafficPolicy?: string;
  loadBalancerIngress?: string[];
};

type ServiceEndpoints = {
  ready: number;
  notReady: number;
  pods?: ServiceEndpointPod[];
};

type ServiceEndpointPod = {
  name: string;
  namespace: string;
  node?: string;
  ready: boolean;
};

type ServiceIngress = {
  name: string;
  namespace: string;
  ingressClassName?: string;
  hosts?: string[];
  tlsCount?: number;
  addresses?: string[];
};

function formatClusterIPs(ips?: string[]) {
  if (!ips || ips.length === 0) return "-";
  return ips.join(", ");
}

function formatIngressHostsSummary(hosts?: string[]) {
  if (!hosts || hosts.length === 0) return "-";
  const short = hosts.slice(0, 3).join(", ");
  if (hosts.length <= 3) return `${hosts.length} (${short})`;
  return `${hosts.length} (${short}, +${hosts.length - 3} more)`;
}

function formatIngressAddresses(addrs?: string[]) {
  if (!addrs || addrs.length === 0) return "-";
  return addrs.join(", ");
}

function formatIngressTlsLabel(count?: number) {
  const num = Number(count || 0);
  return num > 0 ? `Yes (${num})` : "No";
}

function buildExternalUrls(
  summary?: ServiceSummary,
  traffic?: ServiceTraffic,
  ports?: ServicePort[],
): string[] {
  if (!summary) return [];
  const urls: string[] = [];

  if (summary.type === "LoadBalancer" && traffic?.loadBalancerIngress?.length) {
    for (const addr of traffic.loadBalancerIngress) {
      if (!addr) continue;
      const has443 = (ports || []).some((p) => p.port === 443);
      const has80 = (ports || []).some((p) => p.port === 80);
      if (has443) urls.push(`https://${addr}`);
      else if (has80) urls.push(`http://${addr}`);
      else {
        // Show first port
        const first = (ports || [])[0];
        if (first) urls.push(`http://${addr}:${first.port}`);
        else urls.push(`http://${addr}`);
      }
    }
  }

  if (summary.type === "ExternalName" && summary.externalName) {
    urls.push(`http://${summary.externalName}`);
  }

  return urls;
}

export default function ServiceDrawer(props: {
  open: boolean;
  onClose: () => void;
  token: string;
  namespace: string;
  serviceName: string | null;
}) {
  const { retryNonce } = useConnectionState();
  const [tab, setTab] = useState(0);
  const [loading, setLoading] = useState(false);
  const [details, setDetails] = useState<ServiceDetails | null>(null);
  const [events, setEvents] = useState<EventDTO[]>([]);
  const [err, setErr] = useState("");
  const [drawerPod, setDrawerPod] = useState<string | null>(null);
  const [drawerPodNs, setDrawerPodNs] = useState<string>("");
  const [ingresses, setIngresses] = useState<ServiceIngress[]>([]);
  const [ingressesLoading, setIngressesLoading] = useState(false);
  const [ingressesLoaded, setIngressesLoaded] = useState(false);
  const [ingressesErr, setIngressesErr] = useState<ApiError | null>(null);
  const [drawerIngress, setDrawerIngress] = useState<{ name: string; namespace: string } | null>(null);

  const ns = props.namespace;
  const name = props.serviceName;

  useEffect(() => {
    if (!props.open || !name) return;

    setTab(0);
    setErr("");
    setDetails(null);
    setEvents([]);
    setDrawerPod(null);
    setDrawerPodNs("");
    setIngresses([]);
    setIngressesLoading(false);
    setIngressesLoaded(false);
    setIngressesErr(null);
    setDrawerIngress(null);
    setLoading(true);

    (async () => {
      const det = await apiGet<any>(
        `/api/namespaces/${encodeURIComponent(ns)}/services/${encodeURIComponent(name)}`,
        props.token
      );
      const item: ServiceDetails | null = det?.item ?? null;
      setDetails(item);

      const ev = await apiGet<any>(
        `/api/namespaces/${encodeURIComponent(ns)}/services/${encodeURIComponent(name)}/events`,
        props.token
      );
      setEvents(ev?.items || []);
    })()
      .catch((e) => setErr(String(e)))
      .finally(() => setLoading(false));
  }, [props.open, name, ns, props.token, retryNonce]);

  useEffect(() => {
    if (!props.open || !name || tab !== 2) return;
    if (ingressesLoading || ingressesLoaded) return;

    setIngressesLoading(true);
    setIngressesErr(null);

    apiGet<any>(
      `/api/namespaces/${encodeURIComponent(ns)}/services/${encodeURIComponent(name)}/ingresses`,
      props.token
    )
      .then((res) => {
        const items: ServiceIngress[] = res?.items || [];
        setIngresses(items);
      })
      .catch((e) => setIngressesErr(toApiError(e)))
      .finally(() => {
        setIngressesLoading(false);
        setIngressesLoaded(true);
      });
  }, [props.open, name, ns, props.token, tab, ingressesLoading, ingressesLoaded]);

  const summary = details?.summary;
  const endpoints = details?.endpoints;
  const totalEndpoints = (endpoints?.ready || 0) + (endpoints?.notReady || 0);

  const summaryItems = useMemo(
    () => [
      { label: "Name", value: valueOrDash(summary?.name) },
      { label: "Namespace", value: valueOrDash(summary?.namespace) },
      { label: "Type", value: valueOrDash(summary?.type) },
      { label: "Cluster IPs", value: formatClusterIPs(summary?.clusterIPs) },
      {
        label: "Selector",
        value:
          Object.entries(summary?.selector || {}).length === 0 ? (
            "-"
          ) : (
            <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
              {Object.entries(summary?.selector || {}).map(([k, v]) => (
                <Tooltip key={k} title={`${k}=${v}`} arrow>
                  <Chip size="small" label={`${k}=${v}`} />
                </Tooltip>
              ))}
            </Box>
          ),
      },
      { label: "Session Affinity", value: valueOrDash(summary?.sessionAffinity) },
      { label: "Age", value: fmtAge(summary?.ageSec) },
    ],
    [summary]
  );
  const ingressesAccessDenied = ingressesErr?.status === 401 || ingressesErr?.status === 403;

  return (
    <Drawer
      anchor="right"
      open={props.open}
      onClose={props.onClose}
      PaperProps={{
        sx: {
          mt: 8,
          height: "calc(100% - 64px)",
          borderTopLeftRadius: 8,
          borderBottomLeftRadius: 8,
        },
      }}
    >
      <Box sx={{ width: 820, p: 2, display: "flex", flexDirection: "column", height: "100%" }}>
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Service: {name || "-"} <Typography component="span" variant="body2">({ns})</Typography>
          </Typography>
          <IconButton onClick={props.onClose}>
            <CloseIcon />
          </IconButton>
        </Box>

        <Divider sx={{ my: 1 }} />

        {loading ? (
          <Box sx={{ display: "flex", justifyContent: "center", mt: 4 }}>
            <CircularProgress />
          </Box>
        ) : err ? (
          <ErrorState message={err} />
        ) : (
          <>
            <Tabs value={tab} onChange={(_, v) => setTab(v)}>
              <Tab label="Overview" />
              <Tab label="Endpoints" />
              <Tab label="Ingresses" />
              <Tab label="Events" />
              <Tab label="YAML" />
            </Tabs>

            <Box sx={{ mt: 2, flexGrow: 1, minHeight: 0, overflow: "hidden" }}>
              {/* OVERVIEW */}
              {tab === 0 && (
                <Box sx={{ display: "flex", flexDirection: "column", gap: 2, height: "100%", overflow: "auto" }}>
                  <Box sx={{ border: "1px solid #ddd", borderRadius: 2, p: 1.5 }}>
                    <KeyValueTable rows={summaryItems} columns={3} />
                  </Box>

                  <Section title="Ports">
                    {(details?.ports || []).length === 0 ? (
                      <EmptyState message="No ports defined for this Service." sx={{ mt: 1 }} />
                    ) : (
                      <Table size="small" sx={{ mt: 1 }}>
                        <TableHead>
                          <TableRow>
                            <TableCell>Name</TableCell>
                            <TableCell>Service Port</TableCell>
                            <TableCell>Target Port</TableCell>
                            <TableCell>Protocol</TableCell>
                            <TableCell>NodePort</TableCell>
                          </TableRow>
                        </TableHead>
                        <TableBody>
                          {(details?.ports || []).map((p, idx) => (
                            <TableRow key={`${p.name ?? "port"}-${idx}`}>
                              <TableCell>{valueOrDash(p.name)}</TableCell>
                              <TableCell>{valueOrDash(p.port)}</TableCell>
                              <TableCell>{valueOrDash(p.targetPort)}</TableCell>
                              <TableCell>{valueOrDash(p.protocol)}</TableCell>
                              <TableCell>{p.nodePort ? p.nodePort : "-"}</TableCell>
                            </TableRow>
                          ))}
                        </TableBody>
                      </Table>
                    )}
                  </Section>

                  <Section title="Traffic Notes">
                    <KeyValueTable
                      columns={2}
                      sx={{ mt: 1 }}
                      rows={[
                        {
                          label: "External Traffic Policy",
                          value: valueOrDash(details?.traffic?.externalTrafficPolicy),
                        },
                        {
                          label: "LoadBalancer Ingress",
                          value: (details?.traffic?.loadBalancerIngress || []).join(", ") || "-",
                        },
                      ]}
                    />
                  </Section>

                  {(() => {
                    const urls = buildExternalUrls(summary, details?.traffic, details?.ports);
                    if (urls.length === 0) return null;
                    return (
                      <Section title="External URLs">
                        <Box sx={{ display: "flex", flexDirection: "column", gap: 0.5, mt: 1 }}>
                          {urls.map((url) => (
                            <Typography
                              key={url}
                              variant="body2"
                              sx={{ fontFamily: "monospace" }}
                            >
                              <a href={url} target="_blank" rel="noopener noreferrer">
                                {url}
                              </a>
                            </Typography>
                          ))}
                        </Box>
                      </Section>
                    );
                  })()}

                  <MetadataSection labels={details?.summary?.labels} annotations={details?.summary?.annotations} />
                </Box>
              )}

              {/* ENDPOINTS */}
              {tab === 1 && (
                <Box sx={{ display: "flex", flexDirection: "column", gap: 1, height: "100%", overflow: "auto" }}>
                  <Box sx={{ display: "flex", gap: 1, flexWrap: "wrap" }}>
                    <Chip size="small" label={`Ready: ${endpoints?.ready ?? 0}`} color="success" />
                    <Chip size="small" label={`Not Ready: ${endpoints?.notReady ?? 0}`} color="warning" />
                    <Chip size="small" label={`Total: ${totalEndpoints}`} />
                  </Box>

                  {(details?.endpoints?.pods || []).length === 0 ? (
                    <EmptyState message="No endpoints found for this Service." />
                  ) : (
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell>Pod</TableCell>
                          <TableCell>Namespace</TableCell>
                          <TableCell>Node</TableCell>
                          <TableCell>Ready</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {(details?.endpoints?.pods || []).map((p, idx) => (
                          <TableRow
                            key={`${p.namespace}/${p.name}-${idx}`}
                            hover
                            onClick={() => {
                              if (!p.name) return;
                              setDrawerPod(p.name);
                              setDrawerPodNs(p.namespace || ns);
                            }}
                            sx={{ cursor: p.name ? "pointer" : "default" }}
                          >
                            <TableCell>{valueOrDash(p.name)}</TableCell>
                            <TableCell>{valueOrDash(p.namespace)}</TableCell>
                            <TableCell>{valueOrDash(p.node)}</TableCell>
                            <TableCell>
                              <Chip size="small" label={p.ready ? "Ready" : "Not Ready"} color={p.ready ? "success" : "warning"} />
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  )}
                </Box>
              )}

              {/* INGRESSES */}
              {tab === 2 && (
                <Box sx={{ display: "flex", flexDirection: "column", gap: 1, height: "100%", overflow: "auto" }}>
                  {ingressesLoading ? (
                    <Box sx={{ display: "flex", justifyContent: "center", mt: 2 }}>
                      <CircularProgress />
                    </Box>
                  ) : ingressesAccessDenied ? (
                    <AccessDeniedState status={ingressesErr?.status} resourceLabel="Ingresses" />
                  ) : ingressesErr ? (
                    <ErrorState message={ingressesErr.message} />
                  ) : ingresses.length === 0 ? (
                    <EmptyState message="No ingresses reference this Service." />
                  ) : (
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell>Name</TableCell>
                          <TableCell>Class</TableCell>
                          <TableCell>Hosts</TableCell>
                          <TableCell>TLS</TableCell>
                          <TableCell>Address</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {ingresses.map((ing) => (
                          <TableRow
                            key={`${ing.namespace}/${ing.name}`}
                            hover
                            onClick={() =>
                              ing.name && ing.namespace ? setDrawerIngress({ name: ing.name, namespace: ing.namespace }) : null
                            }
                            sx={{ cursor: ing.name ? "pointer" : "default" }}
                          >
                            <TableCell>{valueOrDash(ing.name)}</TableCell>
                            <TableCell>
                              <Chip size="small" label={valueOrDash(ing.ingressClassName)} />
                            </TableCell>
                            <TableCell>{formatIngressHostsSummary(ing.hosts)}</TableCell>
                            <TableCell>
                              <Chip size="small" label={formatIngressTlsLabel(ing.tlsCount)} />
                            </TableCell>
                            <TableCell>{formatIngressAddresses(ing.addresses)}</TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  )}
                </Box>
              )}

              {/* EVENTS */}
              {tab === 3 && (
                <Box sx={{ display: "flex", flexDirection: "column", gap: 1, height: "100%", overflow: "auto" }}>
                  <EventsList events={events} emptyMessage="No events found for this Service." />
                </Box>
              )}

              {/* YAML */}
              {tab === 4 && (
                <CodeBlock code={details?.yaml || ""} language="yaml" />
              )}
            </Box>
            <PodDrawer
              open={!!drawerPod}
              onClose={() => setDrawerPod(null)}
              token={props.token}
              namespace={drawerPodNs || ns}
              podName={drawerPod}
            />
            <IngressDrawer
              open={!!drawerIngress}
              onClose={() => setDrawerIngress(null)}
              token={props.token}
              namespace={drawerIngress?.namespace || ns}
              ingressName={drawerIngress?.name || null}
            />
          </>
        )}
      </Box>
    </Drawer>
  );
}
