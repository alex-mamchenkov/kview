package server

import (
	"context"
	"embed"
	"encoding/json"
	"net/http"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/cors"
	apierrors "k8s.io/apimachinery/pkg/api/errors"

	"kview/internal/cluster"
	"kview/internal/kube"
	"kview/internal/stream"
)

//go:embed ui_dist
var uiFS embed.FS

type Server struct {
	mgr   *cluster.Manager
	token string
}

func New(mgr *cluster.Manager, token string) *Server {
	return &Server{mgr: mgr, token: token}
}

func (s *Server) Router() http.Handler {
	r := chi.NewRouter()

	r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"http://localhost:*", "http://127.0.0.1:*"},
		AllowedMethods:   []string{"GET", "POST", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type"},
		AllowCredentials: false,
		MaxAge:           300,
	}))

	// Protected API
	r.Route("/api", func(api chi.Router) {
		api.Use(s.authMiddleware)

		api.Get("/healthz", func(w http.ResponseWriter, r *http.Request) {
			writeJSON(w, http.StatusOK, map[string]any{
				"ok":            true,
				"activeContext": s.mgr.ActiveContext(),
			})
		})

		api.Get("/contexts", func(w http.ResponseWriter, r *http.Request) {
			writeJSON(w, http.StatusOK, map[string]any{
				"active":   s.mgr.ActiveContext(),
				"contexts": s.mgr.ListContexts(),
			})
		})

		api.Post("/context/select", func(w http.ResponseWriter, r *http.Request) {
			var body struct {
				Name string `json:"name"`
			}
			if err := json.NewDecoder(r.Body).Decode(&body); err != nil || body.Name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid body"})
				return
			}
			if err := s.mgr.SetActiveContext(body.Name); err != nil {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": err.Error()})
				return
			}
			writeJSON(w, http.StatusOK, map[string]any{"active": s.mgr.ActiveContext()})
		})

		api.Get("/namespaces", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 15*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			nss, err := kube.ListNamespaces(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{
				"active":  active,
				"limited": false,
				"items":   nss,
			})
		})

		api.Get("/namespaces/{name}", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetNamespaceDetails(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{name}/summary", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			summary, err := kube.GetNamespaceSummary(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": summary})
		})

		api.Get("/namespaces/{name}/resourcequotas", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			result, err := kube.ListResourceQuotas(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": result.Items})
		})

		api.Post("/auth/can-i", func(w http.ResponseWriter, r *http.Request) {
			var body struct {
				Verb      string  `json:"verb"`
				Resource  string  `json:"resource"`
				Group     string  `json:"group"`
				Namespace *string `json:"namespace"`
			}
			if err := json.NewDecoder(r.Body).Decode(&body); err != nil || body.Verb == "" || body.Resource == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "invalid body"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			res, err := kube.SelfSubjectAccessReview(ctx, clients, kube.AccessReviewRequest{
				Verb:      body.Verb,
				Resource:  body.Resource,
				Group:     body.Group,
				Namespace: body.Namespace,
			})
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"allowed": res.Allowed, "reason": res.Reason})
		})

		api.Get("/nodes", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListNodes(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/nodes/{name}", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing node name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetNodeDetails(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/clusterroles", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListClusterRoles(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/clusterroles/{name}", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing clusterrole name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetClusterRoleDetails(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/clusterroles/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing clusterrole name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, "", "ClusterRole", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/clusterroles/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing clusterrole name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetClusterRoleYAML(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/clusterrolebindings", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListClusterRoleBindings(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/clusterrolebindings/{name}", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing clusterrolebinding name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetClusterRoleBindingDetails(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/clusterrolebindings/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing clusterrolebinding name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, "", "ClusterRoleBinding", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/clusterrolebindings/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing clusterrolebinding name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetClusterRoleBindingYAML(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/customresourcedefinitions", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListCustomResourceDefinitions(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/customresourcedefinitions/{name}", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing customresourcedefinition name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetCustomResourceDefinitionDetails(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/customresourcedefinitions/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing customresourcedefinition name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, "", "CustomResourceDefinition", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/customresourcedefinitions/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing customresourcedefinition name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetCustomResourceDefinitionYAML(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/persistentvolumes", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListPersistentVolumes(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/persistentvolumes/{name}", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing persistentvolume name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetPersistentVolumeDetails(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/persistentvolumes/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing persistentvolume name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, "", "PersistentVolume", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/persistentvolumes/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			name := chi.URLParam(r, "name")
			if name == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing persistentvolume name"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetPersistentVolumeYAML(ctx, clients, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/pods", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			pods, err := kube.ListPods(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": pods})
		})

		api.Get("/namespaces/{ns}/pods/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetPodDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/pods/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForPod(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/pods/{name}/services", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListServicesSelectingPod(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/pods/{name}/logs/ws", (&stream.LogsWS{Mgr: s.mgr}).ServeHTTP)

		api.Get("/namespaces/{ns}/deployments", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListDeployments(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/deployments/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetDeploymentDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/deployments/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "Deployment", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/daemonsets", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListDaemonSets(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/daemonsets/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetDaemonSetDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/daemonsets/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "DaemonSet", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/daemonsets/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetDaemonSetYAML(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/statefulsets", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListStatefulSets(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/statefulsets/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetStatefulSetDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/statefulsets/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "StatefulSet", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/statefulsets/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetStatefulSetYAML(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/replicasets", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListReplicaSets(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/replicasets/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetReplicaSetDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/replicasets/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "ReplicaSet", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/jobs", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListJobs(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/jobs/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetJobDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/jobs/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "Job", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/cronjobs", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListCronJobs(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/cronjobs/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetCronJobDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/cronjobs/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "CronJob", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/services", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListServices(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/services/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetServiceDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/services/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "Service", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/services/{name}/ingresses", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListIngressesForService(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/configmaps", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListConfigMaps(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/configmaps/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetConfigMapDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/configmaps/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "ConfigMap", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/serviceaccounts", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListServiceAccounts(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/serviceaccounts/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetServiceAccountDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/serviceaccounts/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "ServiceAccount", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/serviceaccounts/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetServiceAccountYAML(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/serviceaccounts/{name}/rolebindings", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListRoleBindingsForServiceAccount(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/roles", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListRoles(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/roles/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetRoleDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/roles/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "Role", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/roles/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetRoleYAML(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/rolebindings", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListRoleBindings(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/rolebindings/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetRoleBindingDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/rolebindings/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "RoleBinding", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/rolebindings/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetRoleBindingYAML(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/persistentvolumeclaims", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListPersistentVolumeClaims(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/persistentvolumeclaims/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetPersistentVolumeClaimDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/persistentvolumeclaims/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "PersistentVolumeClaim", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/persistentvolumeclaims/{name}/yaml", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			y, err := kube.GetPersistentVolumeClaimYAML(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "yaml": y})
		})

		api.Get("/namespaces/{ns}/secrets", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListSecrets(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/secrets/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetSecretDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/secrets/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "Secret", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})

		api.Get("/namespaces/{ns}/helmreleases", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListHelmReleases(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/helmreleases/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetHelmReleaseDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/helmcharts", func(w http.ResponseWriter, r *http.Request) {
			ctx, cancel := context.WithTimeout(r.Context(), 30*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListHelmCharts(ctx, clients)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/ingresses", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			if ns == "" {
				writeJSON(w, http.StatusBadRequest, map[string]any{"error": "missing namespace"})
				return
			}

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			items, err := kube.ListIngresses(ctx, clients, ns)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": items})
		})

		api.Get("/namespaces/{ns}/ingresses/{name}", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			det, err := kube.GetIngressDetails(ctx, clients, ns, name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "item": det})
		})

		api.Get("/namespaces/{ns}/ingresses/{name}/events", func(w http.ResponseWriter, r *http.Request) {
			ns := chi.URLParam(r, "ns")
			name := chi.URLParam(r, "name")

			ctx, cancel := context.WithTimeout(r.Context(), 20*time.Second)
			defer cancel()

			clients, active, err := s.mgr.GetClients(ctx)
			if err != nil {
				writeJSON(w, http.StatusInternalServerError, map[string]any{"error": err.Error(), "active": active})
				return
			}

			evs, err := kube.ListEventsForObject(ctx, clients, ns, "Ingress", name)
			if err != nil {
				status := http.StatusInternalServerError
				if apierrors.IsForbidden(err) {
					status = http.StatusForbidden
				}
				writeJSON(w, status, map[string]any{"error": err.Error(), "active": active})
				return
			}

			writeJSON(w, http.StatusOK, map[string]any{"active": active, "items": evs})
		})
	})

	// Public UI (SPA)
	r.Get("/*", s.serveUI)

	return r
}

func (s *Server) authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.Header.Get("Authorization")
		if strings.HasPrefix(token, "Bearer ") {
			token = strings.TrimPrefix(token, "Bearer ")
		} else {
			token = r.URL.Query().Get("token")
		}

		if token != s.token {
			writeJSON(w, http.StatusUnauthorized, map[string]any{"error": "unauthorized"})
			return
		}
		next.ServeHTTP(w, r)
	})
}

func (s *Server) serveUI(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, "/")
	if path == "" {
		path = "ui_dist/index.html"
	} else {
		path = "ui_dist/" + path
	}

	b, err := uiFS.ReadFile(path)
	if err != nil {
		b, err = uiFS.ReadFile("ui_dist/index.html")
		if err != nil {
			http.Error(w, "UI not built", http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write(b)
		return
	}

	w.Header().Set("Content-Type", contentTypeByPath(path))
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write(b)
}

func contentTypeByPath(p string) string {
	switch {
	case strings.HasSuffix(p, ".html"):
		return "text/html; charset=utf-8"
	case strings.HasSuffix(p, ".js"):
		return "application/javascript; charset=utf-8"
	case strings.HasSuffix(p, ".css"):
		return "text/css; charset=utf-8"
	case strings.HasSuffix(p, ".svg"):
		return "image/svg+xml"
	case strings.HasSuffix(p, ".png"):
		return "image/png"
	default:
		return "application/octet-stream"
	}
}

func writeJSON(w http.ResponseWriter, status int, v any) {
	if status >= http.StatusBadRequest {
		if payload, ok := v.(map[string]any); ok {
			if msg, ok := payload["error"].(string); ok && strings.TrimSpace(msg) != "" {
				payload["error"] = sanitizeErrorMessage(status)
				v = payload
			}
		}
	}
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(v)
}

func sanitizeErrorMessage(status int) string {
	switch status {
	case http.StatusBadRequest:
		return "bad request"
	case http.StatusUnauthorized:
		return "unauthorized"
	case http.StatusForbidden:
		return "forbidden"
	case http.StatusNotFound:
		return "not found"
	case http.StatusConflict:
		return "conflict"
	case http.StatusTooManyRequests:
		return "too many requests"
	default:
		return "request failed"
	}
}
