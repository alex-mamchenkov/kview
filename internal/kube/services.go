package kube

import (
	"context"
	"fmt"
	"strings"
	"time"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"

	"kview/internal/cluster"
	"kview/internal/kube/dto"
)

func ListServices(ctx context.Context, c *cluster.Clients, namespace string) ([]dto.ServiceListItemDTO, error) {
	services, err := c.Clientset.CoreV1().Services(namespace).List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, err
	}

	endpointsByName := map[string]*corev1.Endpoints{}
	if endpoints, err := c.Clientset.CoreV1().Endpoints(namespace).List(ctx, metav1.ListOptions{}); err == nil {
		endpointsByName = make(map[string]*corev1.Endpoints, len(endpoints.Items))
		for i := range endpoints.Items {
			ep := endpoints.Items[i]
			endpointsByName[ep.Name] = &ep
		}
	}

	now := time.Now()
	out := make([]dto.ServiceListItemDTO, 0, len(services.Items))
	for _, svc := range services.Items {
		age := int64(0)
		if !svc.CreationTimestamp.IsZero() {
			age = int64(now.Sub(svc.CreationTimestamp.Time).Seconds())
		}

		ready, notReady := endpointsCounts(endpointsByName[svc.Name])

		out = append(out, dto.ServiceListItemDTO{
			Name:              svc.Name,
			Namespace:         svc.Namespace,
			Type:              serviceType(svc.Spec.Type),
			ClusterIPs:        serviceClusterIPs(svc.Spec),
			PortsSummary:      formatServicePortsSummary(svc.Spec.Ports),
			EndpointsReady:    int32(ready),
			EndpointsNotReady: int32(notReady),
			AgeSec:            age,
		})
	}

	return out, nil
}

func formatServicePortsSummary(ports []corev1.ServicePort) string {
	if len(ports) == 0 {
		return ""
	}
	parts := make([]string, 0, len(ports))
	for _, p := range ports {
		base := fmt.Sprintf("%d", p.Port)
		target := serviceIntOrString(p.TargetPort)
		if target != "" && target != base {
			base = fmt.Sprintf("%sâ†’%s", base, target)
		}
		proto := string(p.Protocol)
		if proto == "" {
			proto = "TCP"
		}
		entry := fmt.Sprintf("%s/%s", base, proto)
		if p.NodePort != 0 {
			entry = fmt.Sprintf("%s (NP %d)", entry, p.NodePort)
		}
		parts = append(parts, entry)
	}
	return strings.Join(parts, ", ")
}

func endpointsCounts(ep *corev1.Endpoints) (int, int) {
	if ep == nil {
		return 0, 0
	}
	ready := 0
	notReady := 0
	for _, subset := range ep.Subsets {
		ready += len(subset.Addresses)
		notReady += len(subset.NotReadyAddresses)
	}
	return ready, notReady
}

func serviceClusterIPs(spec corev1.ServiceSpec) []string {
	if len(spec.ClusterIPs) > 0 {
		return append([]string{}, spec.ClusterIPs...)
	}
	if spec.ClusterIP != "" {
		return []string{spec.ClusterIP}
	}
	return nil
}

func serviceType(t corev1.ServiceType) string {
	if t == "" {
		return "ClusterIP"
	}
	return string(t)
}

func serviceIntOrString(v intstr.IntOrString) string {
	if v.Type == intstr.String {
		return v.StrVal
	}
	if v.IntVal == 0 {
		return ""
	}
	return fmt.Sprintf("%d", v.IntVal)
}
